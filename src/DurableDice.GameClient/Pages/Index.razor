@implements IDisposable

@page "/"
@page "/{gameId}"

@using Blazored.LocalStorage
@using DurableDice.Common.Abstractions
@using DurableDice.Common.Models.Commands
@using DurableDice.GameClient.Services
@using Microsoft.AspNetCore.SignalR.Client;
@using DurableDice.Common.Models.State;

@if (!_connected)
{
	<p class="connection-state">Connecting..</p>
}

@if (string.IsNullOrEmpty(_playerName))
{
	<input placeholder="Enter your name" @bind="@_newPlayerName" maxlength="16" />
	<button @onclick="JoinAsync">Join</button>
}
else if (_gameState == null)
{
	<p>Loading..</p>
}
else if (_gameState != null)
{
	<div class="players">
		@foreach (var (player, index) in _players)
		{
			var fields = _gameState.PlayerFieldCount(player);
			var className = $"player player-{index}";
			if (player.Id == _gameState.ActivePlayerId)
			{
				className += " player-active";
			}
			if (player.Id == _playerId)
			{
				className += " player-you";
			}
			if (fields == 0)
			{
				className += " player-dead";
			}
			if (!player.Ready)
			{
				className += " player-not-ready";
			}

			<div class=@className>
				@player.Name (@player.ContinuousFieldCount | @player.DiceBuffer)
			</div>
		}
	</div>

	if (!_gameState.Fields.Any())
	{
		<div class="buttons">
			<button @onclick="ReadyAsync">Ready</button>
		</div>
	}

	if (_gameState.Winner is Player winner)
	{
		<p>@winner.Name won</p>
	}
	else if (_gameState.Fields.Any())
	{
		<div class="buttons">
			@if (_gameState.PlayerIsDead(_playerId))
			{
				<p>You are dead.</p>
			}
			else if (_gameState.ActivePlayerId == _playerId)
			{
				<p>It's your turn! Attack your neighbor or <button @onclick="EndRoundAsync">end round</button></p>
			}
			else
			{
				<p>Please wait for your turn.</p>
			}
		</div>

		<div class="fields">
			@foreach (var (field, index) in _fields)
			{
				var ownerIndex = _gameState.Players.FindIndex(x => x.Id == field.OwnerId);
				var fieldModifier = field.Id[^1];
				var className = $"hexagon field-{index} player-{ownerIndex}  mod-{fieldModifier}";
				var modifierClassName = "modifier";

				if (_gameState.ActivePlayerId == _playerId)
				{
					if (_playerId == field.OwnerId && field.DiceCount > 1 ||
					(field.OwnerId != _playerId && !string.IsNullOrWhiteSpace(_fromFieldId) && _gameState.Geometry.AreNeighboringFields(_fromFieldId, field.Id)))
					{
						className += " field-hoverable";
					}

					if (field.Id == _fromFieldId)
					{
						modifierClassName += " mod-attack";
					}
				}

				if (field.Id != _fromFieldId)
				{
					if (_gameState.PreviousAttack?.IsSuccessful == true && field.Id == _gameState.PreviousAttack?.DefendingFieldId)
					{
						modifierClassName += " mod-attacking-success";
					}
					else if (_gameState.PreviousAttack?.IsSuccessful == false && field.Id == _gameState.PreviousAttack?.AttackingFieldId)
					{
						modifierClassName += " mod-defending-success";
					}

					if (field.DiceAdded > 0)
					{
						modifierClassName += $" mod-{field.DiceAdded}-dice-added";
					}
				}

				@foreach (var coordinate in field.Coordinates)
				{
					var (left, top) = Position(coordinate);

					<div class=@className style="left: @(left)px; top: @(top)px;" @onclick=@(() => FieldClickAsync(field)) onmouseenter="this.parentNode.dataset.hover = '@index'" onmouseleave="this.parentNode.dataset.hover = ''">
						<div class="left"></div>
						<div class="middle"></div>
						<div class="right"></div>
						<div class=@modifierClassName>
							<div class="left"></div>
							<div class="middle"></div>
							<div class="right"></div>
						</div>
					</div>
				}

				{
					var (left, top) = Position(field.Center);

					<div class="label" style="left: @(left)px; top: @(top)px;" @onclick=@(() => FieldClickAsync(field)) onmouseenter="this.parentNode.dataset.hover = '@index'" onmouseleave="this.parentNode.dataset.hover = ''">
						@field.DiceCount
					</div>
				}
			}
		</div>

		@if (_gameState.PreviousAttack is Attack attack)
		{
			<div class="attack">
				<div class="attacker player-@(_gameState.PlayerIndex(attack.AttackerId))">@attack.AttackingDiceCount</div>
				<div class="attacked">@DescribeAttack(attack)</div>
				<div class="defender player-@(_gameState.PlayerIndex(attack.DefenderId))">@attack.DefendingDiceCount</div>
			</div>
		}
	}
}

@code
{
	[Inject]
	public NavigationManager navManager { get; set; } = null!;

	[Inject]
	public ISyncLocalStorageService localStorage { get; set; } = null!;

	[Parameter]
	public string? GameId { get; set; }

	private bool _connected = true;

	private string _playerId { get; set; } = Guid.NewGuid().ToString();
	private string _newPlayerName = "";
	private string _playerName = "";

	private string _hoveringFieldId = "";

	private string _fromFieldId = "";
	private bool _attacking = false;

	private IGameEntity _gameEntity = null!;

	private GameState? _gameState;

	private IEnumerable<(Player player, int index)> _players
		=> _gameState?.Players.Select((player, index) => (player, index)) ?? throw new Exception();

	private IEnumerable<(Field field, int index)> _fields
		=> _gameState?.Fields.Select((field, index) => (field, index)) ?? throw new Exception();

	protected override void OnInitialized()
	{
		var localStoragePlayerId = "";

		if (string.IsNullOrEmpty(GameId) || !Guid.TryParse(GameId, out _))
		{
			GameId = Guid.NewGuid().ToString();
			navManager.NavigateTo($"/{GameId}", false);
		}
		else
		{
			localStoragePlayerId = localStorage.GetItem<string>($"playerId-{GameId}");
			_playerId = localStoragePlayerId;
			_playerName = _playerId;
		}

		Console.WriteLine($"Joined game '{GameId}' as player '{_playerId}' -- (local storage player '{localStoragePlayerId}')");

		var gameEntityService = new GameEntityService(GameId, (navManager.BaseUri.Contains("localhost")) ? "http://localhost:7071" : "https://durabledice.azurewebsites.net");
		gameEntityService.NewStateReceived += NewState;
		gameEntityService.ConnectionState += ConnectionState;

		_gameEntity = gameEntityService;
	}

	private void NewState(GameState state)
	{
		_gameState = state;

		if (_attacking)
		{
			_attacking = false;
			_fromFieldId = "";
		}

		StateHasChanged();
	}

	private void ConnectionState(bool connected)
	{
		_connected = connected;
		StateHasChanged();
	}

	private async Task JoinAsync()
	{
		if (!string.IsNullOrWhiteSpace(_newPlayerName))
		{
			_playerName = _newPlayerName;
			_playerId = Guid.NewGuid().ToString();
			localStorage.SetItem<string>($"playerId-{GameId}", _playerId);

			Console.WriteLine("Saving playerId");

			await _gameEntity.AddPlayerAsync(new AddPlayerCommand(_playerId, _playerName));
		}
	}

	private async Task ReadyAsync() => await _gameEntity.ReadyAsync(_playerId);
	private async Task EndRoundAsync() => await _gameEntity.EndRoundAsync(_playerId);

	private async Task FieldClickAsync(Field field)
	{
		if (_attacking || _gameState == null || _gameState.ActivePlayerId != _playerId)
		{
			return;
		}

		if (string.IsNullOrEmpty(_fromFieldId))
		{
			if (field.OwnerId == _playerId && field.DiceCount > 1)
			{
				_fromFieldId = field.Id;
			}
		}
		else if (field.Id == _fromFieldId)
		{
			_fromFieldId = "";
		}
		else if (field.OwnerId != _playerId)
		{
			await _gameEntity.AttackFieldAsync(new AttackMoveCommand(_playerId, _fromFieldId, field.Id));
			_attacking = true;
		}

		StateHasChanged();
	}

	public void Dispose()
	{
		if (_gameEntity is GameEntityService service)
		{
			service.NewStateReceived -= NewState;
		}
	}

	public (int left, int top) Position(Coordinate coordinate)
	{
		var left = coordinate.X % 2 == 1
			? coordinate.X * 21
			: coordinate.X * 21;
		var top = coordinate.X % 2 == 1
			? 12 + coordinate.Y * 24
			: coordinate.Y * 24;

		return (left, top);
	}

	public string DescribeAttack(Attack attack)
	{
		var diceDelta = attack.AttackingDiceCount - attack.DefendingDiceCount;
		switch (diceDelta)
		{
			case < -15: return "got owned by";
			case < -10: return "never stood a change with";
			case < -5: return "underestimated";
			case < 0: return "came short against";
			case 0: return "did not have enough for";
			case < 5: return "barely won of";
			case < 10: return "bullied";
			case < 15: return "destroyed";
			default: return "obliterated";
		};
	}
}